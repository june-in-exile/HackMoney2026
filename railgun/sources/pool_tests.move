/// Integration tests for Privacy Pool
#[test_only]
module railgun::pool_tests {
    use sui::test_scenario::{Self as ts, Scenario};
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;
    use railgun::pool::{Self, PrivacyPool};

    // Test addresses
    const ADMIN: address = @0xAD;
    const ALICE: address = @0xA11CE;
    const BOB: address = @0xB0B;

    // Test verification key (from unshield circuit compilation)
    // Generated by: node convert_unshield_to_sui.js
    const TEST_VK: vector<u8> = x"e2f26dbea299f5223b646cb1fb33eadb059d9407559d7441dfd902e3a79a4d2dabb73dc17fbc13021e2471e0c08bd67d8401f52b73d6d07483794cad4778180e0c06f33bbc4c79a9cadef253a68084d382f17788f885c9afd176f7cb2f036789edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e198f1ca32b8c078cd1ecfc4a467d8db364b3757d39102fa1ed9255e280333144297c184af83775c6ea998cfb4d59fbd7317b3435e152bace861d478fe0bbcf148f0400000000000000191f71d49c7ecfcc3643957f0d503d24e713cf91937a8a33b7c118a6afef44891ef0fa65bcfbe5a8f6a5a1bb098b6e508467a66a10af02338ce1560ff9609f1588d71006852b8f431fd5d3de34357325e41f3252748926d16c27ed7cb789478068d1e927470885642b8adcd4b38f20583984d85f9274e93b39f834daacf80b0b";

    // Test proof (valid proof for the test input)
    const TEST_PROOF: vector<u8> = x"aca940a9ad7c4beb620beb1b67cd111a2ff32b2f33945bd12cc017c721ec1b91083135faffb3ff4b3cfdcdd0a075154e80b245fa42d14655880096b4ef29fe13f274371b7b8b1d8382f61ba9b61d2901b3557944195ee34771eaee3f0019571cba7b3a4b43ffdd48945edd122d141734a262be4b49e6baf28abeea0c1484050a";

    // Test public inputs [merkle_root, nullifier, commitment]
    const TEST_PUBLIC_INPUTS: vector<u8> = x"2fcfefda413c3b48e0806fb76f38678760d9dc9e23eaecaec3c5c6265298202350c899e811771f3b5b77a50bcde42ab8822a6c8b41b57e4cea8f0c00645da926589b6f5789efc87da100ca0b91394f7454370d77d4f64569e64bca988b98be2c";

    // Test commitment (from test input generation)
    // commitment = Poseidon(NPK, token, value)
    const TEST_COMMITMENT: vector<u8> = x"589b6f5789efc87da100ca0b91394f7454370d77d4f64569e64bca988b98be2c";

    // Test nullifier
    const TEST_NULLIFIER: vector<u8> = x"50c899e811771f3b5b77a50bcde42ab8822a6c8b41b57e4cea8f0c00645da926";

    // ============ Helper Functions ============

    fun create_test_pool(scenario: &mut Scenario) {
        ts::next_tx(scenario, ADMIN);
        {
            let ctx = ts::ctx(scenario);
            let pool = pool::create_pool<SUI>(TEST_VK, ctx);
            transfer::public_share_object(pool);
        };
    }

    fun mint_sui(scenario: &mut Scenario, amount: u64, recipient: address) {
        ts::next_tx(scenario, ADMIN);
        {
            let ctx = ts::ctx(scenario);
            let coin = coin::mint_for_testing<SUI>(amount, ctx);
            transfer::public_transfer(coin, recipient);
        };
    }

    // ============ Tests ============

    #[test]
    fun test_create_pool() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);

        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);

            // Verify initial state
            assert!(pool::get_balance(&pool) == 0, 0);
            assert!(pool::get_note_count(&pool) == 0, 1);

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    fun test_shield() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);
        mint_sui(&mut scenario, 1_000_000_000, ALICE); // 1 SUI

        // Shield tokens
        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let coin = ts::take_from_sender<Coin<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            pool::shield(
                &mut pool,
                coin,
                TEST_COMMITMENT,
                x"0102030405060708", // Placeholder encrypted note data
                ctx
            );

            // Verify state after shield
            assert!(pool::get_balance(&pool) == 1_000_000_000, 0);
            assert!(pool::get_note_count(&pool) == 1, 1);

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    fun test_multiple_shields() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);
        mint_sui(&mut scenario, 1_000_000_000, ALICE);
        mint_sui(&mut scenario, 2_000_000_000, BOB);

        // Alice shields
        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let coin = ts::take_from_sender<Coin<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            pool::shield(&mut pool, coin, x"0000000000000000000000000000000000000000000000000000000000000001", x"01", ctx);

            assert!(pool::get_balance(&pool) == 1_000_000_000, 0);
            assert!(pool::get_note_count(&pool) == 1, 1);

            ts::return_shared(pool);
        };

        // Bob shields
        ts::next_tx(&mut scenario, BOB);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let coin = ts::take_from_sender<Coin<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            pool::shield(&mut pool, coin, x"0000000000000000000000000000000000000000000000000000000000000002", x"02", ctx);

            assert!(pool::get_balance(&pool) == 3_000_000_000, 0);
            assert!(pool::get_note_count(&pool) == 2, 1);

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    #[expected_failure(abort_code = pool::E_INVALID_ROOT)]
    fun test_unshield_invalid_root() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);
        mint_sui(&mut scenario, 1_000_000_000, ALICE);

        // Shield first (but with different commitment than what proof expects)
        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let coin = ts::take_from_sender<Coin<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            // Shield with a different commitment
            pool::shield(&mut pool, coin, x"0000000000000000000000000000000000000000000000000000000000000099", x"99", ctx);
            ts::return_shared(pool);
        };

        // Try to unshield - should fail because merkle root in proof doesn't match
        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            pool::unshield(
                &mut pool,
                TEST_PROOF,
                TEST_PUBLIC_INPUTS,
                1_000_000_000,
                BOB,
                ctx
            );

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    #[expected_failure(abort_code = pool::E_INVALID_PUBLIC_INPUTS)]
    fun test_unshield_invalid_public_inputs_length() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);

        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            // Try with invalid length public inputs
            pool::unshield(
                &mut pool,
                TEST_PROOF,
                x"0102030405", // Invalid length (5 bytes, should be 96)
                1_000_000_000,
                BOB,
                ctx
            );

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    fun test_nullifier_tracking() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);

        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);

            // Initially nullifier should not be spent
            assert!(!pool::is_nullifier_spent(&pool, TEST_NULLIFIER), 0);

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }

    #[test]
    fun test_get_merkle_root() {
        let mut scenario = ts::begin(ADMIN);
        create_test_pool(&mut scenario);
        mint_sui(&mut scenario, 1_000_000_000, ALICE);

        // Get initial root
        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let root1 = pool::get_merkle_root(&pool);
            assert!(vector::length(&root1) == 32, 0);
            ts::return_shared(pool);
        };

        // Shield and verify root changes
        ts::next_tx(&mut scenario, ALICE);
        {
            let mut pool = ts::take_shared<PrivacyPool<SUI>>(&scenario);
            let coin = ts::take_from_sender<Coin<SUI>>(&scenario);
            let ctx = ts::ctx(&mut scenario);

            let root_before = pool::get_merkle_root(&pool);
            pool::shield(&mut pool, coin, x"0000000000000000000000000000000000000000000000000000000000000003", x"03", ctx);
            let root_after = pool::get_merkle_root(&pool);

            // Root should change after shield
            assert!(root_before != root_after, 0);

            ts::return_shared(pool);
        };

        ts::end(scenario);
    }
}
